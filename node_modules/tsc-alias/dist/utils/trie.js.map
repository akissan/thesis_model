{"version":3,"file":"trie.js","sourceRoot":"","sources":["../../src/utils/trie.ts"],"names":[],"mappings":";;;AAIA,MAAa,QAAQ;IAInB;QACE,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;QAC1B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;IAQM,GAAG,CAAC,IAAY,EAAE,IAAO;QAC9B,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC;YAAE,OAAO;QAC7B,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACrC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAE;YAC7B,CAAC,CAAC,IAAI,QAAQ,EAAK,CAAC;QACtB,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE;YACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SAClB;aAAM;YACL,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;SACnC;QACD,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IACnC,CAAC;IAOM,MAAM,CAAC,IAAY;QACxB,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC;YAAE,OAAO,IAAI,CAAC;QAElC,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QACxC,IAAI,IAAI,EAAE;YACR,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE;gBACpB,OAAO,IAAI,CAAC,IAAI,CAAC;aAClB;iBAAM;gBACL,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9C,OAAO,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;aACpC;SACF;aAAM;YACL,OAAO,IAAI,CAAC,IAAI,CAAC;SAClB;IACH,CAAC;CACF;AAhDD,4BAgDC","sourcesContent":["/**\n * TrieNode is a prefix tree.\n * [Trie](https://en.wikipedia.org/wiki/Trie)\n */\nexport class TrieNode<T> {\n  private children: Map<string, TrieNode<T>>;\n  public data: T | null;\n\n  constructor() {\n    this.children = new Map();\n    this.data = null;\n  }\n\n  /**\n   * add adds an alias to the prefix tree.\n   * @param name the prefix of the alias.\n   * @param data the alias data.\n   * @returns void.\n   */\n  public add(name: string, data: T) {\n    if (name.length <= 0) return;\n    const node = this.children.has(name[0])\n      ? this.children.get(name[0])!\n      : new TrieNode<T>();\n    if (name.length == 1) {\n      node.data = data;\n    } else {\n      node.add(name.substring(1), data);\n    }\n    this.children.set(name[0], node);\n  }\n\n  /**\n   * search searches the prefix tree for the most correct alias data for a given prefix.\n   * @param name the prefix to search for.\n   * @returns the alias data or null.\n   */\n  public search(name: string): T | null {\n    if (name.length <= 0) return null;\n\n    const node = this.children.get(name[0]);\n    if (node) {\n      if (name.length == 1) {\n        return node.data;\n      } else {\n        const result = node.search(name.substring(1));\n        return result ? result : node.data;\n      }\n    } else {\n      return this.data;\n    }\n  }\n}\n"]}